import pyrealsense2 as rs
import numpy as np
import cv2
import matplotlib.pyplot as plt

# Set up the RealSense pipeline for depth streaming
pipeline = rs.pipeline()
config = rs.config()
config.enable_stream(rs.stream.depth, 320, 240, rs.format.z16, 30)  # Configure the depth stream resolution

# Start the pipeline
pipeline.start(config)

def region_of_interest_edge(img, vertices):
    mask = np.zeros_like(img)
    cv2.fillPoly(mask, vertices, 255)
    masked_image = cv2.bitwise_and(img, mask)
    return masked_image

roi_vertices = [
    (0, 240),  # Left base point
    (320, 240),  # Right base point
    (160, 120)   # Top vertex
]

# Define a function to find the longest horizontal line
def find_longest_horizontal_line(contours):
    longest_line = None
    max_length = 0

    for contour in contours:
        epsilon = 0.001 * cv2.arcLength(contour, True)
        approx = cv2.approxPolyDP(contour, epsilon, True)

        for i in range(len(approx) - 1):
            x1, y1 = approx[i][0]
            x2, y2 = approx[i + 1][0]

            if abs(y1 - y2) < 60:
                length = np.sqrt((x2 - x1)**2 + (y2 - y1)**2)
                if length > max_length:
                    max_length = length
                    longest_line = [(x1, y1), (x2, y2)]

    return longest_line

try:
    while True:
        # Capture frames from the depth stream
        frames = pipeline.wait_for_frames()
        depth_frame = frames.get_depth_frame()
        if not depth_frame:
            continue

        # Convert depth frame to numpy array
        depth_image = np.asanyarray(depth_frame.get_data())
        
        # Normalize depth image for visualization and edge detection
        depth_image_normalized = cv2.normalize(depth_image, None, 0, 255, cv2.NORM_MINMAX).astype(np.uint8)

        # Apply ROI mask to the depth image
        cropped_image_edge = region_of_interest_edge(depth_image_normalized, np.array([roi_vertices], np.int32))
        
        # Edge detection on depth data
        edges_edge = cv2.GaussianBlur(cropped_image_edge, (9, 9), 0)
        edges_edge = cv2.Canny(edges_edge, 100, 400)
        kernel_edge = np.ones((5, 5), np.uint8)
        edges_edge = cv2.dilate(edges_edge, kernel_edge, iterations=3)

        # Find contours in the edge-detected image
        contours, _ = cv2.findContours(edges_edge, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)

        # Find the longest horizontal line
        longest_horizontal_line = find_longest_horizontal_line(contours)

        if longest_horizontal_line is not None:
            (x1, y1), (x2, y2) = longest_horizontal_line
            cv2.circle(depth_image_normalized, (x1, y1), 5, (255, 0, 0), -1)
            cv2.circle(depth_image_normalized, (x2, y2), 5, (255, 0, 0), -1)
            print(f"Edge points: ({x1}, {y1}) and ({x2}, {y2})")
        else:
            print("No horizontal line detected.")

        # Display the edge detection result
        cv2.imshow('Depth Edge Detection', edges_edge)
        cv2.imshow('Detected Edges', depth_image_normalized)

        # Press 'q' to exit
        if cv2.waitKey(1) & 0xFF == ord('q'):
            break
finally:
    # Stop the pipeline
    pipeline.stop()
    cv2.destroyAllWindows()
