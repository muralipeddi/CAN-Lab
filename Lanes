import cv2
import numpy as np
import pyrealsense2 as rs  # RealSense SDK
import matplotlib.pyplot as plt

# Initialize RealSense pipeline
pipeline = rs.pipeline()
config = rs.config()
config.enable_stream(rs.stream.depth, 640, 480, rs.format.z16, 30)  # Configure depth stream
pipeline.start(config)

def region_of_interest(image, vertices):
    mask = np.zeros_like(image)
    cv2.fillPoly(mask, vertices, 255)
    return cv2.bitwise_and(image, mask)

def detect_edges(depth_image):
    gray = cv2.convertScaleAbs(depth_image, alpha=0.03)  # Scale to 8-bit grayscale
    blur = cv2.GaussianBlur(gray, (9, 9), 0)
    edges = cv2.Canny(blur, 50, 100)
    return edges

def find_lane_lines(image, edges):
    height, width = image.shape[:2]
    polygons = np.array([
        [(100, height), (int(width*0.4), int(height*0.6)),
         (int(width*0.6), int(height*0.6)), (width - 100, height)]
    ])
    masked_edges = region_of_interest(edges, polygons)

    lines = cv2.HoughLinesP(masked_edges, 2, np.pi/180, 100, np.array([]), minLineLength=5, maxLineGap=70)
    return lines

def display_lines(image, lines):
    line_image = np.zeros_like(image)
    if lines is not None:
        for line in lines:
            x1, y1, x2, y2 = line.reshape(4)
            cv2.line(line_image, (x1, y1), (x2, y2), (255, 0, 0), 10)
    return line_image

def get_distance_to_point(depth_frame, x, y):
    # Retrieve the depth value at a specific pixel coordinate
    distance = depth_frame.get_distance(x, y)
    return distance

try:
    while True:
        # Capture frames from the depth stream
        frames = pipeline.wait_for_frames()
        depth_frame = frames.get_depth_frame()
        if not depth_frame:
            continue

        # Convert depth frame to numpy array for processing
        depth_image = np.asanyarray(depth_frame.get_data())
        edges = detect_edges(depth_image)

        # Find lane lines
        lane_lines = find_lane_lines(depth_image, edges)
        lane_image = display_lines(depth_image, lane_lines)
        
        # Overlay lane lines on original depth image
        combo_image = cv2.addWeighted(depth_image, 0.8, lane_image, 1, 1)

        # Get depth for edges on longest horizontal line (if detected)
        contours, _ = cv2.findContours(edges, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
        longest_horizontal_line = find_longest_horizontal_line(contours)
        
        if longest_horizontal_line:
            (x1, y1), (x2, y2) = longest_horizontal_line
            dist1 = get_distance_to_point(depth_frame, x1, y1)
            dist2 = get_distance_to_point(depth_frame, x2, y2)
            cv2.circle(combo_image, (x1, y1), 5, (0, 255, 0), -1)
            cv2.circle(combo_image, (x2, y2), 5, (0, 255, 0), -1)
            print(f"Edge Points Distances: {dist1:.2f} m, {dist2:.2f} m")

        # Show processed frame
        cv2.imshow('Lane Detection - Depth Stream', combo_image)

        if cv2.waitKey(1) & 0xFF == ord('q'):
            break
finally:
    # Stop the RealSense pipeline
    pipeline.stop()
    cv2.destroyAllWindows()
